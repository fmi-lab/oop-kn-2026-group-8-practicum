# Седмица 02 - Структури

## Структури в C++
Структурите в C++ са съставен тип данни, който представлява съвкупност от елементи от произволен тип, обединени в един общ обект. Елементите в структурите се наричат полета или член-данни и по подразбиране имаме свободен достъп до тях. Няма ограничение в броя на полетата в структурата. Дефиницията на структура създава потребителски тип, с който може да оперираме по същия начин, както и с останалите типове в езика. Пример за дефиниция на структура:
```c++
struct Person {
  char name[30];
  int age;
  double weight;
};
```

## Работа със структури
След като дефинираме структура, трябва да можем да създаваме нейни инстанции - това са обектите, които са от типа, зададен от структурата. Както стана дума, с тях се оперира по същия начин както и с останалите типове - следователно можем да създаваме инстанции статични и динамично. Да разгледаме различните начини за създаване на инстанции на структурата от горния пример:
```c++
Person p1;
Person p2{"Ivan", 20, 74.5};
Person p3 = {"Ivan", 20, 74.5};
Person* p4 = new Person;
Person* p5 = new Person{"Ivan", 20, 74.5};
Person p6 = {
  .name = "Ivan",
  .age = 20,
  .weight = 74.5
};
```

- `p1` създава обекта със стойности по подразбиране на полетата;
- `p2` създава обекта със стойности на полетата равни на тези в къдравите скоби. Стойностите в къдравите скоби се присвояват на полетата в реда, в който са дефинирани полетата в структурата. Това е познатият ни от преди `list initialization`;
- `p3` води до същия резултат като `p2`, с разликата, че това е стандартния начин за присвояване на стойност на променлива, който сме свикнали да ползваме при работата с прости типове. На практика обектът се създава от дясната страна на `=` и само се присвоява на променливата отляво - т.е. `p3` копира стойностите на полетата в обекта от дясно на `=`;
- `p4` създава динамично обект със стойности по подразбиране;
- `p5` създава динамично обект по същия начин както `p2`. Ако се опитаме да сложим `=` като в `p3` ще получим грешка, понеже при динамично инициализиране на обекти трябва да укажем какви да са стойностите на техните полета и не можем да копираме други структури в тях.
- `p6` е аналогичен начин за инициализация като `p2` и `p3`, но за по-добра четимост се добавят и имената на член-данните в инициализиращия списък. Въпреки това, редът трябва да е същия като в дефиницията.

След като видяхме как се инициализират обекти нека видим как да достъпваме техните полета:
```c++
std::cout << p2.name << ' ' << p2.age << ' ' << p2.weight << '\n'; // -> Ivan 20 74.5
std::cout << p5->name << ' ' << p5->age << ' ' << p5->weight << '\n'; // -> Ivan 20 74.5
```

- първият ред е пример за достъпване на полетата от обект - това става с оператора `"."`. Освен, че може да ги достъпваме, може и да променяме стойностите на полетата:
```c++
p2.age = 21;
```
- вторият ред е пример за достъпване на полетата от указател към обект. На практика операторът `"->"` е просто синтактична захар за дереференциране на обекта и използването на `"."`:
```c++
(*p5).name <=> p5->name
```

## Представяне на структурите в паметта
Както стана ясно, структурите просто обединяват няколко променливи в общ обект. Това ни навява на мисълта, че най-вероятно структурите се представят в паметта, като просто полетата се разположат последователно в нея. Можем да използваме оператора `sizeof`, за да видим колко точно байта заема подадения обект в паметта. Нека го използваме за нашата структура `Person`:
```c++
std::cout << sizeof(Person) << '\n';
```

Очакваме резултата от горния ред да бъде сумата от размерите на полетата в структурата - 30 + 4 + 8 = 42. В действително резултата е 48. Това е така, защото полетата се подравняват - адресът, от който започват полетата, трябва да се дели на техния размер. Допълнително, общият размер на структурата трябва да се дели на машинната дума - в случая 8 байта. Да разгледаме следните 2 примера:
```c++
struct Person1 {
  char blood_type;
  double weight;
  char name[30];
};

struct Person2 {
  double weight;
  char name[30];
  char blood_type;
};

int main() {
  std::cout << sizeof(Person1) << ' ' << sizeof(Person2) << '\n';
  return 0;
}
```

Резултата от горния пример е, че `Person1` заема 48 байта, а `Person2` - 40 байта. Разликата идва от позицията на `blood_type` - в първия случай, `weight` трябва да започва от адрес, който се дели на 8 и понеже `blood_type` заема само 1 байт, трябва да се допълнят още 7 байта и накрая имаме общо 46 байта, но трябва общият размер да се дели на 8, следователно получаваме общо 48 байта. В другия случай не се налага да се добавят никакви байтове между отделните полета, следователно накрая имаме общо 39 байта и отново трябва да се подравни самата структура и получаваме общо 40 байта. Това показва, че на практика има значение в какъв ред ще слагаме полетата в структурите.

## Рекурсивни структури
Сега като знаем как се разполагат структурите в паметта, можем да си зададем въпроса какво се случва в следния пример:
```c++
struct Person {
  char name[30];
  Person mother; 
};
```

За да се разположи в паметта, първо трябва да се сметне размера на отделните полета на структурата. Но когато трябва да се изчисли размера на `mother` трябва да се изчисли рекурсивно размерът на `Person`. Така получаваме безкрайна рекурсия за смятане на размера на `Person` и затова ще получим компилационна грешка. Начинът, по който можем да разрешим проблема, е като променим типа на `mother` да е `Person*` - указателите винаги имат фиксиран размер - размерът на машинната дума. Така вече можем да сметнем размера на `Person` (който е?) и до голяма степен да запазим поведението, което сме очаквали първоначално за тази структура.

## Методи
Освен член-данни, структурите могат да съдържат и методи. Това са функции, които са част от дефиницият на структурите и имат свободен достъп до член-данните на структурите.
```c++
struct Person {
  char name[30];
  int age;
  double weight;

  void print() {
    std::cout << name << ' ' << age << ' ' << weight << '\n';
  }
};
```

Извикването на метод е аналогично на достъпа до член-данни и се извършва чрез операторите `.` и `->`.

```c++
p2.print() // -> Ivan 20 74.5
p5->print() // -> Ivan 20 74.5
```


## Задача 01 - Студент
Да се напише структура, която представлява студент в университет, съдържаща име, факултетен номер, курс и списък от оценки. Оценките представляват структура от името на предмет и оценката към него. Всеки студент може да има най-много 100 оценки. Добавете следните методи към структурата за студент:
- `grade` - намира средния успех на студента;
- `print` - извежда подробна информация за студента (имате избор за конкретния формат);
- `add_mark` - приема оценка и я добавя към списъка с оценки на студента. Ако вече има оценка за същия предмет, то тогава да не се добавя нова оценка, а да се промени съществуващата (все едно е оценка от повишителен изпит).

### Пример:
```c++
Student student_ivan{
  .name = "Ivan Ivanov",
  .fn = "3MI0800092",
  .year = 2,
  .marks = {
    {"Linear algebra", 5.56},
    {"Intro to programming", 5.84},
    {"Discrete structures", 4.35}
  },
  .marks_count = 3
};

student_ivan.print();

/*
Name: Ivan Ivanov
Faculty number: 3MI0800092
Year: 2
Marks:
 - Linear algebra: 5.56
 - Intro to programming: 5.84
 - Discrete structures: 4.35
Average grade: 5.25
*/
```

## Задача 02 - Масив от студенти
Да се напише структура, която представлява динамичен масив от студенти. Структурата да съдържа масив от студенти, броят студенти в масива и капацитета на масива (размерът, с който е бил заделен). Да се добави метод за добавяне на студент към масива. Ако няма достатъчно капацитет, масивът да се преоразмери, така че да може да се добави студентът.

### Пример:
```c++
StudentArray students{
  .data = new Student[1]{student_ivan},
  .capacity = 1,
  .size = 1 
};

Student student_petkan{
  .name = "Petkan Georgiev",
  .fn = "5MI0800145",
  .year = 1,
  .marks = {
    {"Discrete structures", 3.75},
    {"Mathematical analysis", 4.25}
  },
  .marks_count = 2
};

students.push_back(student_petkan);

for (std::size_t i = 0; i < students.size; ++i) {
  students.data[i].print();
  std::cout << '\n';
}

delete [] students.data;
/*
Name: Ivan Ivanov
Faculty number: 3MI0800092
Year: 2
Marks:
 - Linear algebra: 5.56
 - Intro to programming: 5.84
 - Discrete structures: 4.35
Average grade: 5.25

Name: Petkan Georgiev
Faculty number: 5MI0800145
Year: 1
Marks:
 - Discrete structures: 3.75
 - Mathematical analysis: 4.25
Average grade: 4
*/
```

## Задача 03 - Университет
Да се напише структура университет, съдържаща име на университета и списък от студенти. Добавете следните методи към структурата:
- `add_student` - приема студент и добавя студента към университета;
- `find_student` - приема факултетен номер и връща указател към студента, на когото отговаря факултетния номер. Ако такъв студент няма, да се върне `nullptr`;
- `get_by_year` - приема номер на курс и връща масив от студентите в подадения курс;
- `get_by_subject` - приема име на предмет и връща масив от студентите, имащи оценка по подадения предмет;
- `print` - извежда подробна информация за университета (отново имате избор за конкретния формат);

### Пример:
```c++
University university{
  .name = "Sofia University \"St. Kliment Ohridski\"",
  .students = students
};

Student* student = university.find_student("5MI0800145");

if (student) {
  std::cout << "Found student:\n";
  student->print();
} else {
  std::cout << "Missing student with faculty number: 5MI0800145\n"; 
}

delete [] students.data;

/*
Found student:
Name: Petkan Georgiev
Faculty number: 5MI0800145
Year: 1
Marks:
 - Discrete structures: 3.75
 - Mathematical analysis: 4.25
Average grade: 4
*/
```